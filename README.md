Introduction
------------

This document discusses scenarios that could result in XML signature
verification failure.  It is meant to be a general reference, although examples
are limited to certain tools and infrastructure.


Incorrectly-Named `id` Attribute
--------------------------------

When `/EntityDescriptor/Signature/SignedInfo/Reference/@URI` is assigned a
reference to an element with a specific `id` value (i.e. when the URI string
begins with `#`), then there needs to be an element with a _lower-case_
`id` attribute with that value.  Since XML is case-sensitive, `Id`, `iD`, and
`ID` are invalid.

However, one cannot simply fix the casing of the attribute name and be done 
with it, as this invalidates the digital signature.  (I have empirically 
confirmed this to be the case, which goes to show that the _attributes_ are 
digitally signed as well as the descendant nodes.)

The fix is to inform the signature verifier what attribute should be searched
for instead of `id` when the referential URI string starts with `#`.  In the
case of `xmlsec1`, the syntax of the relevant option is as follows:

    --id-attr[:<attr-name>] [<node-namespace-uri>:]<node-name>


For example, the following `xmlsec1` options may be used when verifying SAML
metadata generated by the Kentor AuthServices library (which assigns an `ID`
attribute to the `EntityDescriptor` element, the signed part of the document):

    --id-attr:ID EntityDescriptor


Untrusted / Self-Signed Certificates
------------------------------------

By itself, a valid signature only guarantees that a message has not been
tampered with, corrupted, or otherwise modified since it was signed.  If the
recipient does not know where the public key came from (and has no way of
figuring it out), then the recipient cannot cryptographically confirm the
identity of the signer.  Without this knowledge, the authenticity of the
message is put into question.

Generally, there are two ways to confirm where a public key came from.  In the
first case, the owner of the public key transmits it to the receiving party
over a trusted communication channel.  The receiving party then stores the key
in a secure location and refers to it when verifying signatures.  The other
method is for an already-trusted party to independently verify the identity of
the public key's owner on the recipient's behalf.  The most common way to do
that is by having a trusted CA sign a certificate containing the public key.

Relevant `xmlsec1` options:

* `--keys-file <file>`
* `--pubkey-pem[:<name>] <file>`
* `--pubkey-der[:<name>] <file>`
* `--trusted-pem <file>`
* `--trusted-der <file>`
* `--X509-skip-strict-checks`
* `--insecure` (use this if you do **NOT** want to authenticate the signer)

_**TODO:** Discuss the rationale behind including certificates with signed
data during transport vs. not doing so.  Also discuss the security concerns of
retrieving SAML entity metadata from a web address (also consider HTTP vs.
HTTPS addresses)._


Changes to Whitespace
---------------------

Yes, whitespace matters when it comes to digitally-signed data.  If the line
endings change, that will invalidate the signature.  If the data was indented
to increase readability, that will invalidate the signature.  If base64-encoded
data is split into 64-character lines -- you guessed it -- that will invalidate
the signature.  The only part of an XML document that can be modified is the
part that isn't signed. (You can figure out what has been signed by looking at
the enveloped signature attributes.)

If you want to change whitespace of signed data, make sure to verify the
signature and possibly store an original copy of the data before doing so.
